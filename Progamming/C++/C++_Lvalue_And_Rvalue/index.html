<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="Furrybear">
    <link rel="canonical" href="https://furrybear.readthedocs.com/Progamming/C++/C++_Lvalue_And_Rvalue/">
    <link rel="shortcut icon" href="../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>左值和右值（C++11之前） - Furrybear's Blog</title>
    <link href="../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\u5de6\u503c\u548c\u53f3\u503c\uff08C++11\u4e4b\u524d\uff09", url: "#_top", children: [
          ]},
          {title: "\u53f3\u503c\u5f15\u7528T &amp;&amp;", url: "#t-ampamp", children: [
          ]},
          {title: "\u5de6\u503c\u3001\u5c06\u4ea1\u503c\u3001\u7eaf\u53f3\u503c", url: "#_1", children: [
          ]},
          {title: "\u79fb\u52a8\u8bed\u4e49\uff08Move Semantic\uff09\u548c\u5b8c\u7f8e\u8f6c\u53d1\uff08Perfect Forward\uff09", url: "#move-semanticperfect-forward", children: [
              {title: "\u79fb\u52a8\u6784\u9020\u51fd\u6570", url: "#_2" },
              {title: "std::move", url: "#stdmove" },
              {title: "std::forward", url: "#stdforward" },
          ]},
          {title: "\u51fd\u6570\u8fd4\u56de\u53f3\u503c\u5f15\u7528", url: "#_3", children: [
          ]},
        ];

    </script>
    <script src="../../../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../C++_Object_Oriented_Programming/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../C++_Object_Oriented_Programming/" class="btn btn-xs btn-link">
        C++ Object Oriented Programming
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../C++_Details/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../C++_Details/" class="btn btn-xs btn-link">
        C++中除以0的行为
      </a>
    </div>
    
  </div>

    

    <h1 id="c11">左值和右值（C++11之前）</h1>
<p>参考：<a href="http://www.cnblogs.com/catch/p/3500678.html">http://www.cnblogs.com/catch/p/3500678.html</a></p>
<p>参考：<a href="http://www.cnblogs.com/catch/p/3507883.html">http://www.cnblogs.com/catch/p/3507883.html</a></p>
<p>参考：<a href="https://www.cnblogs.com/qicosmos/p/4283455.html">https://www.cnblogs.com/qicosmos/p/4283455.html</a></p>
<p>左值、右值是表达式的属性。</p>
<p>左值指的是既能够出现在等号左边也能出现在等号右边的变量(或表达式)。右值指的则是只能出现在等号右边的变量(或表达式)，例如<code>1+2</code>。</p>
<p>左值是有名字的变量，右值是由运算操作(加减乘除、函数调用返回值等)所产生的中间结果（没有名字）。</p>
<p>左值可以寻址，右值不能寻址。</p>
<h1 id="t-ampamp">右值引用<code>T &amp;&amp;</code></h1>
<p>C++11引入了右值引用<code>T &amp;&amp;</code>用来指向右值。</p>
<p>形如<code>T &amp;&amp;a = foo();</code>延长了返回值（右值）的生命周期，而<code>T a = foo();</code>需要经历一次拷贝构造（其实如果编译器开了RVO/NRVO优化的话也可以优化掉这个拷贝构造）。</p>
<p>对于基础类型，右值引用对象不能被修改，也不可被const、volatile所修饰；对于自定义类型，右值引用对象允许通过它的成员函数进行修改。</p>
<p>右值引用对象表示这个对象是濒死的，以后不再使用的。作为输入参数，表示这个对象的内容和资源可以被搬空而不用采用深拷贝。</p>
<p>因此，左值能被<code>T &amp;</code>和<code>const T &amp;/T const&amp;</code>指向，右值能被<code>const T &amp;/T const&amp;</code>和<code>T &amp;&amp;</code>指向。</p>
<h1 id="_1">左值、将亡值、纯右值</h1>
<p>C++11将表达式分为左值（Left Value, lvalue），将亡值（Expiring Value, xvalue），纯右值（Pure Right Value, prvalue）。</p>
<p>C++11之前的右值和C++11中的纯右值是等价的。</p>
<p>将亡值是被右值引用指向的那个值。</p>
<p>据我观察，左值和将亡值都是可以取到地址的，而纯右值取地址编译会报错。</p>
<pre><code class="cpp">#include &lt;iostream&gt;
using namespace std;

int main(int argc, char const* argv[])
{
    int&amp;&amp; a = 1;
    const int&amp; b = 2;
    cout &lt;&lt; &amp;a &lt;&lt; endl;
    cout &lt;&lt; &amp;b &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>原因见<a href="https://www.v2ex.com/t/492033#reply28">这里</a>，由于将纯右值绑定给右值引用或者常量引用，所以编译器不得不将1放到栈中并分配内存地址。</p>
<p>左值和将亡值合称泛左值(Generalized Lvalue, glvalue)。</p>
<p>纯右值和将亡值合称右值(Right Value, rvalue)。</p>
<p><img alt="" src="../lvalue_and_rvalue.png" /></p>
<p><img alt="" src="../for_example.jpg" /></p>
<ul>
<li>左值：some_variable</li>
<li>将亡值：std::move(some_variable)</li>
<li>纯右值：1+3，函数返回的临时变量</li>
</ul>
<h1 id="move-semanticperfect-forward">移动语义（Move Semantic）和完美转发（Perfect Forward）</h1>
<h2 id="_2">移动构造函数</h2>
<p>对于一个对象，如果需要将这个对象的资源交给另一个同类型对象，并且不再需要这个对象（一般是函数返回的临时对象等），可以给这个类创建移动构造函数<code>class_name(class_name&amp;&amp; other);</code>。</p>
<p>一个类的移动构造函数的语义是接收一个右值引用对象，移动构造完毕后，之前那个右值引用对象将不能被使用。</p>
<h2 id="stdmove">std::move</h2>
<p>返回参数的右值引用。从对象进入move函数，就不要再使用这个对象，因为它做好了被移动的准备。</p>
<h2 id="stdforward">std::forward</h2>
<p>如果一个函数接受了一个右值引用参数，但在函数体内，这个参数其实被视为一个左值。</p>
<p>对于以下例子：</p>
<pre><code class="cpp">#include &lt;iostream&gt;
using namespace std;

namespace std {
//版本1
void func_overridden(int&amp;&amp; a)
{
    cout &lt;&lt; &quot;Run function which received rvalue reference.&quot; &lt;&lt; endl;
}
//版本2
void func_overridden(int&amp; a)
{
    cout &lt;&lt; &quot;Run function which received lvalue reference.&quot; &lt;&lt; endl;
}
template &lt;class A&gt;
void factory(A&amp;&amp; a)
{
    return func_overridden(forward&lt;A&gt;(a));
}
}

int main()
{
    factory(5);//调用版本1
    int a = 2;
    factory(a);//调用版本2
}
</code></pre>

<p>std::forward能将参数真正的左右值属性转发给其他函数。</p>
<p>（为什么factory函数需要声明为函数模板？）</p>
<h1 id="_3">函数返回右值引用</h1>
<p>如果函数声明为返回右值引用，然后返回函数内创建的非静态本地对象的话，是错误的！因为返回后，这个对象已经不存在了。</p>

  <br>
    

    
    
      
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../C++_Object_Oriented_Programming/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../C++_Object_Oriented_Programming/" class="btn btn-xs btn-link">
        C++ Object Oriented Programming
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../C++_Details/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../C++_Details/" class="btn btn-xs btn-link">
        C++中除以0的行为
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="col-md-12 wm-page-content">
      <p>
        <a href="https://github.com/furrybear/furrybear.github.io/edit/src/notes/Progamming/C++/C++_Lvalue_And_Rvalue.md"><i class="fa fa-github"></i>
Edit on GitHub</a>
      </p>
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>